/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package cn.xxxxxx.iser.jmtrace;

import cn.xxxxxx.iser.jmtrace.testcases.*;
import cn.xxxxxx.iser.jmtrace.testcases.*;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.MethodOrderer;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.TestMethodOrder;

import java.util.Arrays;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

@TestMethodOrder(value = MethodOrderer.MethodName.class)
class AppTest {
    @Test
    void testOnlyStatic() throws Exception {
        Tracer.setDebug(false);

        var onlyStatic = TestUtils.transform(OnlyStatic.class);
        TestUtils.invokeStaticVoid(onlyStatic, "dumb");
        var output = Tracer.consumeOutput();

        TestUtils.invokeStaticVoid(onlyStatic, "staticPut");
        output = Tracer.consumeOutput();
        TestUtils.assertOutputMatch(Arrays.asList(
                "W.*intField",
                "W.*doubleField",
                "W.*objectField"
        ), output);

        TestUtils.invokeStaticVoid(onlyStatic, "staticGet");
        output = Tracer.consumeOutput();
        TestUtils.assertOutputMatch(Arrays.asList(
                "R.*objectField",
                "R.*doubleField",
                "R.*intField"
        ), output);
    }

    @Test
    void testOnlyField() throws Exception {
        Tracer.setDebug(true);

        var onlyField = TestUtils.transform(OnlyField.class);

        Runnable resetOnlyField = () -> {
            Assertions.assertDoesNotThrow(() -> TestUtils.invokeStaticVoid(onlyField, "reset"));
            Tracer.consumeOutput();
        };

        String output = "";
        resetOnlyField.run();

        TestUtils.invokeStaticVoid(onlyField, "fieldGet");
        output = Tracer.consumeOutput();

        TestUtils.invokeStaticVoid(onlyField, "fieldPut");
        output = Tracer.consumeOutput();
    }

    @Test
    void testOnlyArray() throws Exception {
        Tracer.setDebug(true);

        var onlyArray = TestUtils.transform(OnlyArray.class);
        String output;
        Tracer.consumeOutput();

        TestUtils.invokeStaticVoid(onlyArray, "loadArray");
        output = Tracer.consumeOutput();
        TestUtils.assertOutputMatch(Arrays.asList(
                "R.*int\\[0\\]",
                "R.*double\\[0\\]",
                "R.*java.lang.Object\\[0\\]"
        ), output);

        TestUtils.invokeStaticVoid(onlyArray, "storeArray");
        output = Tracer.consumeOutput();
        TestUtils.assertOutputMatch(Arrays.asList(
                "W.*int\\[0\\]",
                "W.*double\\[0\\]",
                "W.*java.lang.Object\\[0\\]"
        ), output);
    }

    @Test
    void testCompose() throws Exception {
        var composeClass = TestUtils.transform(Compose.class);
        String output = Tracer.consumeOutput();

        Tracer.setDebug(true);
        TestUtils.invokeStaticVoid(composeClass, "reset");

        TestUtils.invokeStaticVoid(composeClass, "run");
    }

    @Test
    void testMultiThread() throws Exception {
        int nThreads = 3;
        ExecutorService executor = Executors.newWorkStealingPool(nThreads);
        var latch = new CountDownLatch(nThreads);
        var multiThreadClass = TestUtils.transform(MultiThread.class);

        Tracer.consumeOutput();

        TestUtils.invokeStaticVoid(multiThreadClass, "reset");
        for (int i = 0; i < nThreads; i++) {
            executor.execute(() -> {
                Assertions.assertDoesNotThrow(() -> {
                    try {
                        TestUtils.invokeStaticVoid(multiThreadClass, "run");
                    } finally {
                        latch.countDown();
                    }
                });
            });
        }
        executor.shutdown();
        latch.await();
    }
}
